{{/*
@component: Lazy Image
@description: Displays images with lazy-loading and automatic WebP support, responsive sizes, and optimization for different screens.
@params:
  - src: Path to the source image (required)
  - alt: Alternative text for accessibility (required)
  - class: Additional CSS classes (optional)
  - id: Image ID (optional)
  - width: Image width (optional)
  - height: Image height (optional)
  - maxWidth: Maximum image width for loading (optional)
@example:
  {{ partial "components/media/lazyimg.html" (dict 
      "src" "/images/blog/featured-image.jpg" 
      "alt" "Featured blog image" 
      "class" "rounded-lg shadow-md"
      "maxWidth" 800
  ) }}
@note: The component automatically looks for preprocessed image versions in the /images/processed/ directory, maintaining the original directory structure.
*/}}

{{ $src := .src }}
{{ $alt := .alt | default "" }}
{{ $class := .class | default "" }}
{{ $classPicture := .classPicture | default "" }}
{{ $id := .id | default "" }}
{{ $width := .width | default "" }}
{{ $height := .height | default "" }}
{{ $maxWidth := .maxWidth | default 3000 }}

{{ if or (strings.HasSuffix $src ".svg") (strings.HasSuffix $src ".SVG") }}
  <!-- SVGs: skip <picture> and srcset logic, just use <img> with lazy loading -->
  <img 
    class="lazy-image {{ with $class }}{{ . }}{{ end }}"
    data-src="{{ $src }}"
    alt="{{ $alt }}"
    {{ with $id }}id="{{ . }}"{{ end }}
    {{ with $width }}width="{{ . }}"{{ end }}
    {{ with $height }}height="{{ . }}"{{ end }}
    loading="lazy"
    decoding="async"
    data-original-src="{{ $src }}"
  >
{{ else }}

    {{ $availableWidths := slice 150 300 768 1024 }}

    <!-- Extract paths for processed images -->
    {{ $filename := path.Base $src }}
    {{ $extension := path.Ext $filename }}
    {{ $basename := replace $filename $extension "" }}
    {{ $dirPath := path.Dir $src }}

    <!-- Extract the relative path inside /images/ directory -->
    {{ $relativePath := $dirPath }}
    {{ if hasPrefix $dirPath "/images/" }}
      {{ $relativePath = substr $dirPath 8 }}
    {{ end }}

    <!-- Create processed directory path that mirrors original structure -->
    {{ $processedDirPath := path.Join "/images/processed" $relativePath }}
    {{ if not (eq $processedDirPath "/images/processed") }}
      {{ $processedDirPath = printf "%s/" $processedDirPath }}
    {{ else }}
      {{ $processedDirPath = "/images/processed/" }}
    {{ end }}

    <!-- Initialize variables -->
    {{ $useOriginal := false }}

    <!-- 1 & 2. Get original image dimensions -->
    {{ $originalImagePath := printf "static%s" $src }}
    {{ $originalWidth := 0 }}
    {{ if fileExists $originalImagePath }}
      {{ with (imageConfig $originalImagePath) }}
        {{ $originalWidth = .Width }}
      {{ end }}
    {{ end }}

    <!-- Add the original width to availableWidths if maxWidth is larger than original width -->
    {{ if and (gt $maxWidth 0) (gt $maxWidth $originalWidth) (gt $originalWidth 0) }}
      {{ $foundOriginal := false }}
      {{ range $availableWidths }}
        {{ if eq . $originalWidth }}
          {{ $foundOriginal = true }}
        {{ end }}
      {{ end }}
      {{ if not $foundOriginal }}
        {{ $availableWidths = $availableWidths | append $originalWidth }}
      {{ end }}
    {{ end }}

    <!-- 3. Validate if processed image exists for each size and keep only those that do -->
    {{ $validatedWidths := slice }}
    {{ range $availableWidths }}
      {{ $width := . }}
      {{ $processedPath := printf "%s%s-%d%s" $processedDirPath $basename $width $extension }}
      {{ if fileExists (printf "static%s" $processedPath) }}
        {{ $validatedWidths = $validatedWidths | append $width }}
      {{ end }}
    {{ end }}
    {{ $availableWidths = $validatedWidths }}

    <!-- 4. If maxWidth is defined, remove from the list all images bigger than one step above maxWidth -->
    {{ if gt $maxWidth 0 }}
      <!-- Find the next size up from maxWidth -->
      {{ $nextSize := 0 }}
      {{ $sortedForNext := sort $availableWidths }}
      {{ range $sortedForNext }}
        {{ if gt . $maxWidth }}
          {{ $nextSize = . }}
          {{ break }}
        {{ end }}
      {{ end }}

      <!-- Filter the list to keep only up to the next size -->
      {{ if gt $nextSize 0 }}
        {{ $filteredByMax := slice }}
        {{ range $availableWidths }}
          {{ if le . $nextSize }}
            {{ $filteredByMax = $filteredByMax | append . }}
          {{ end }}
        {{ end }}
        {{ $availableWidths = $filteredByMax }}
      {{ end }}
    {{ end }}

    <!-- Add original image to srcset if maxWidth is larger than original width -->
    {{ if and (gt $maxWidth 0) (gt $maxWidth $originalWidth) (gt $originalWidth 0) }}
      <!-- Always include original image regardless of processed images -->
      {{ $useOriginal = true }}
    {{ end }}

    <!-- If no processed images found, or we need to use original image -->
    {{ if or (eq (len $availableWidths) 0) $useOriginal }}
      {{ $useOriginal = true }}
      <!-- Use original width if known, or a default width -->
      {{ if gt $originalWidth 0 }}
        <!-- Make sure originalWidth is in the availableWidths array -->
        {{ $foundOriginal := false }}
        {{ range $availableWidths }}
          {{ if eq . $originalWidth }}
            {{ $foundOriginal = true }}
          {{ end }}
        {{ end }}
        {{ if not $foundOriginal }}
          {{ $availableWidths = $availableWidths | append $originalWidth }}
        {{ end }}
      {{ else }}
        <!-- Default fallback if we can't determine original width -->
        {{ $availableWidths = slice 1024 }}
      {{ end }}
    {{ end }}

    <!-- Generate dynamic sizes attribute based on available widths -->
    {{ $sizesAttr := "" }}
    {{ $sortedWidths := sort $availableWidths }}
    {{ $lastWidth := 0 }}

    {{ range $index, $width := $sortedWidths }}
      <!-- For each width, create a media query that specifies using this width when viewport is up to this wide -->
      {{ if $sizesAttr }}
        {{ $sizesAttr = printf "%s, " $sizesAttr }}
      {{ end }}
      {{ $sizesAttr = printf "%s(max-width: %dpx) %dpx" $sizesAttr $width $width }}
      {{ $lastWidth = $width }}
    {{ end }}

    <!-- For larger viewports, use the largest available width -->
    {{ if $sizesAttr }}
      {{ $sizesAttr = printf "%s, %dpx" $sizesAttr $lastWidth }}
    {{ else }}
      {{ $sizesAttr = printf "%dpx" $lastWidth }}
    {{ end }}

    <!-- 5. Build srcset for original format and WebP based on validated widths -->
    {{ $fallbackSrc := $src }}
    {{ $optimizedOriginalPath := printf "%s%s%s" $processedDirPath $basename $extension }}
    {{ $hasOptimizedOriginal := fileExists (printf "static%s" $optimizedOriginalPath) }}

    <!-- If optimized original exists, use it instead of the original -->
    {{ if $hasOptimizedOriginal }}
      {{ $fallbackSrc = $optimizedOriginalPath }}
    {{ end }}

    <!-- Build srcset for original format and WebP -->
    {{ $origSrcset := "" }}
    {{ $webpSrcset := "" }}

    <!-- Original WebP path -->
    {{ $originalWebpPath := printf "%s%s.webp" $processedDirPath $basename }}
    {{ $useOriginalWebp := fileExists (printf "static%s" $originalWebpPath) }}

    <!-- Collect available widths into maps for processed images -->
    {{ $availableSrcWidths := slice }}
    {{ $availableWebpWidths := slice }}

    <!-- Process each available width for -width suffixed versions -->
    {{ range $sortedWidths }}
      {{ $currentWidth := . }}

      <!-- Define paths to preprocessed images with directory structure -->
      {{ $currentSrcPath := printf "%s%s-%d%s" $processedDirPath $basename $currentWidth $extension }}
      {{ $currentWebpPath := printf "%s%s-%d.webp" $processedDirPath $basename $currentWidth }}

      <!-- Check if preprocessed images exist and add to available widths lists -->
      {{ if fileExists (printf "static%s" $currentSrcPath) }}
        {{ $availableSrcWidths = $availableSrcWidths | append (dict "width" $currentWidth "path" $currentSrcPath) }}
      {{ end }}

      {{ if fileExists (printf "static%s" $currentWebpPath) }}
        {{ $availableWebpWidths = $availableWebpWidths | append (dict "width" $currentWidth "path" $currentWebpPath) }}
      {{ end }}
    {{ end }}

    <!-- Add the optimized original image if needed -->
    {{ if and $hasOptimizedOriginal $useOriginal }}
      {{ $availableSrcWidths = $availableSrcWidths | append (dict "width" $originalWidth "path" $optimizedOriginalPath) }}
    {{ end }}

    <!-- Add original WebP to $availableWebpWidths regardless of $useOriginal flag if it exists -->
    {{ if $useOriginalWebp }}
      {{ $foundOriginalWebp := false }}
      {{ range $availableWebpWidths }}
        {{ if eq .path $originalWebpPath }}
          {{ $foundOriginalWebp = true }}
        {{ end }}
      {{ end }}
      {{ if not $foundOriginalWebp }}
        {{ $availableWebpWidths = $availableWebpWidths | append (dict "width" $originalWidth "path" $originalWebpPath) }}
      {{ end }}
    {{ end }}

    <!-- Sort available widths in ASCENDING order (smallest first) for srcset -->
    {{ $availableSrcWidths = sort $availableSrcWidths "width" "asc" }}
    {{ $availableWebpWidths = sort $availableWebpWidths "width" "asc" }}

    <!-- Build srcset with smallest sizes first -->
    {{ range $availableSrcWidths }}
      {{ if $origSrcset }}
        {{ $origSrcset = printf "%s, %s %dw" $origSrcset .path .width }}
      {{ else }}
        {{ $origSrcset = printf "%s %dw" .path .width }}
      {{ end }}
    {{ end }}

    <!-- Build WebP srcset with smallest sizes first -->
    {{ range $availableWebpWidths }}
      {{ if $webpSrcset }}
        {{ $webpSrcset = printf "%s, %s %dw" $webpSrcset .path .width }}
      {{ else }}
        {{ $webpSrcset = printf "%s %dw" .path .width }}
      {{ end }}
    {{ end }}

    <!-- If no processed WebP images exist, use original WebP if it exists -->
    {{ if and (not $webpSrcset) $useOriginalWebp }}
      {{ $webpSrcset = printf "%s %dw" $originalWebpPath $originalWidth }}
    {{ end }}

    <!-- If no processed images exist, use original (or fallbackSrc) -->
    {{ if not $origSrcset }}
      {{ $origSrcset = printf "%s %dw" $fallbackSrc $originalWidth }}
    {{ end }}

    {{/* Determine MIME type based on file extension */}}
    {{ $fileExt := strings.ToLower (path.Ext $src) }}
    {{ $mimeType := "image/octet-stream" }} {{/* Default fallback */}}
    {{ if eq $fileExt ".jpeg" }}
      {{ $mimeType = "image/jpeg" }}
    {{ else if eq $fileExt ".jpg" }}
      {{ $mimeType = "image/jpeg" }}
    {{ else if eq $fileExt ".png" }}
      {{ $mimeType = "image/png" }}
    {{ else if eq $fileExt ".webp" }}
      {{ $mimeType = "image/webp" }}
    {{ else if eq $fileExt ".gif" }}
      {{ $mimeType = "image/gif" }}
    {{ end }}

    <!-- Construct the picture tag based on the list of available images -->
    <picture class="lazy-picture {{ with $classPicture }}{{ . }}{{ end }}" maxWidthParam="{{ $maxWidth }}">
      <!-- WebP sources with lazy loading -->
      {{ if $webpSrcset }}
      <source
        type="image/webp"
        srcset="{{ $webpSrcset }}"
        sizes="{{ $sizesAttr }}"
        data-original-src="{{ $src }}"
      >
      {{ end }}

      <!-- Original format sources with lazy loading -->
      <source
        type="{{ $mimeType }}"
        srcset="{{ $origSrcset }}"
        sizes="{{ $sizesAttr }}"
        data-original-src="{{ $src }}"
      >

      <!-- Fallback image with lazy loading -->
      <img
        src="{{ $fallbackSrc }}"
        alt="{{ $alt }}" 
        class="lazy-image {{ with $class }}{{ . }}{{ end }}"
        {{ with $id }}id="{{ . }}"{{ end }}
        {{ with $width }}width="{{ . }}"{{ end }}
        {{ with $height }}height="{{ . }}"{{ end }}
        loading="lazy"
        decoding="async"
        data-original-src="{{ $src }}"
        >
    </picture>
{{ end }}
